/*
 * generated by Xtext
 */
package at.ac.tuwien.big.xmltext.library3.serializer;

import Library3.AnyGenericAttribute;
import Library3.AnyGenericElement;
import Library3.AnyGenericText;
import Library3.BookInfoType;
import Library3.BookType;
import Library3.CustomerType;
import Library3.Library3Package;
import Library3.LibraryType;
import at.ac.tuwien.big.xmltext.library3.services.Library3GrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractLibrary3SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Library3GrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Library3Package.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Library3Package.ANY_GENERIC_ATTRIBUTE:
				sequence_AnyGenericAttribute(context, (AnyGenericAttribute) semanticObject); 
				return; 
			case Library3Package.ANY_GENERIC_ELEMENT:
				sequence_AnyGenericElement(context, (AnyGenericElement) semanticObject); 
				return; 
			case Library3Package.ANY_GENERIC_TEXT:
				sequence_AnyGenericText(context, (AnyGenericText) semanticObject); 
				return; 
			case Library3Package.BOOK_INFO_TYPE:
				sequence_BookInfoType(context, (BookInfoType) semanticObject); 
				return; 
			case Library3Package.BOOK_TYPE:
				sequence_BookType(context, (BookType) semanticObject); 
				return; 
			case Library3Package.CUSTOMER_TYPE:
				sequence_CustomerType(context, (CustomerType) semanticObject); 
				return; 
			case Library3Package.LIBRARY_TYPE:
				sequence_LibraryType(context, (LibraryType) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == EcorePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case EcorePackage.EOBJECT:
				sequence_EObject(context, (EObject) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (attrName=STRING attrValue=STRING)
	 */
	protected void sequence_AnyGenericAttribute(EObject context, AnyGenericAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Library3Package.Literals.ANY_GENERIC_ATTRIBUTE__ATTR_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Library3Package.Literals.ANY_GENERIC_ATTRIBUTE__ATTR_NAME));
			if(transientValues.isValueTransient(semanticObject, Library3Package.Literals.ANY_GENERIC_ATTRIBUTE__ATTR_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Library3Package.Literals.ANY_GENERIC_ATTRIBUTE__ATTR_VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAnyGenericAttributeAccess().getAttrNameSTRINGTerminalRuleCall_0_0(), semanticObject.getAttrName());
		feeder.accept(grammarAccess.getAnyGenericAttributeAccess().getAttrValueSTRINGTerminalRuleCall_2_0(), semanticObject.getAttrValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         elemName=STRING? 
	 *         elemValue=STRING? 
	 *         (anyGenericAttr+=AnyGenericAttribute anyGenericAttr+=AnyGenericAttribute*)? 
	 *         (anyGenericElement+=AnyGenericElement anyGenericElement+=AnyGenericElement*)?
	 *     )
	 */
	protected void sequence_AnyGenericElement(EObject context, AnyGenericElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (textValue=STRING?)
	 */
	protected void sequence_AnyGenericText(EObject context, AnyGenericText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((any+=AnyGenericElement any+=AnyGenericElement*)?)
	 */
	protected void sequence_BookInfoType(EObject context, BookInfoType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID0 
	 *         title=STRING 
	 *         author=NameType 
	 *         pages=Int0 
	 *         isbn=IsbnType 
	 *         bookInfo=BookInfoType?
	 *     )
	 */
	protected void sequence_BookType(EObject context, BookType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (firstName=STRING lastName=STRING borrowedBookId=[EObject|IDREF]?)
	 */
	protected void sequence_CustomerType(EObject context, CustomerType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {EObject}
	 */
	protected void sequence_EObject(EObject context, EObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((book+=BookType book+=BookType*)? (customer+=CustomerType customer+=CustomerType*)?)
	 */
	protected void sequence_LibraryType(EObject context, LibraryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
